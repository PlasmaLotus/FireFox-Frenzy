#include <math.h>
#include <cmath>
#include "Player.h"
#include "../Main.h"
#include "GameLogic.h"
#include "../States/StateManager.h"

Player::Player():
	Player(nullptr) 
{
}

Player::Player(GameLogic *g) :
SquareEntity(0,0,GameLogic::PLAYER_COLLISION_HITBOX_WIDTH, GameLogic::PLAYER_COLLISION_HITBOX_HEIGHT),
_game(g),
state(PlayerState::Moving)

{
	posX = 10.f;
	posY = 10.f;
	//posZ = 10.f;
	velocityX = 0.f;
	velocityY = 0.f;
	orientation = 0.f;
	orientationX = 0.f;
	orientationY = 0.f;
	cursorOrientation = 0.f;
	cursorOrientationX = 0.f;
	cursorOrientationY = 0.f;
	shootHeld = false;
	dashVelocity = 5.0f;
	dashMaxDuration = 150;
	dashTime = 0;
	ammo = 500;
	//dashAmmo = 3;
	shieldActive = false;
	_shieldActive = false;
	_shieldActiveDuration = 0;
	_shield.width = GameLogic::PLAYER_SHIELD_RADIUS;
	_shield.height = GameLogic::PLAYER_SHIELD_RADIUS;
}

Player::~Player()
{
}

void Player::setGame(GameLogic * g)
{
	_game = g;
}

GameLogic * Player::getGame()
{
	return _game;
}

bool Player::isAlive() {
	return true;
}
void Player::update(int32_t dt)
{
	Entity::update(dt);
	_handleMovement(dt);
	/*Projectiles*/
	//handleProjectiles(dt);
	shootHeld = false;
	shootCooldownTime--;
	if (shootCooldownTime <= 0) {
		canShoot = true;
	}
	handleShooting(dt);
	/*Recharging ammo*/
	handleAmmo(dt);
	/*Shield*/
	handleShield(dt);
	handleDash(dt);
}

void Player::setPlayerOrienation(float x, float y)
{
	orientation = std::atan2(x, y);
	orientationX = x;
	orientationY = y;
}

void Player::setCursorOrientation(float x, float y)
{
	cursorOrientation = std::atan2(x, y);
	cursorOrientationX = x;
	cursorOrientationY = y;
}

void Player::setCursorOrientationFromMouse(int x, int y)
{
	//printf("MousePos: %d, %d\n", x, y);
	setCursorOrientation( x - posX , y - posY);
}

bool Player::testCollision(Entity e) {
	if (shieldActive) {
		return _shield.testCollision(e);
	}
	else {
		return SquareEntity::testCollision(e);
	}
}

bool Player::testCollision(SquareEntity e) {
	if (shieldActive) {
		return _shield.testCollision(e);
	}
	else {
		return SquareEntity::testCollision(e);
	}
}

bool Player::testCollision(CircleEntity e) {
	if (shieldActive) {
		return _shield.testCollision(e);
	}
	else {
		return SquareEntity::testCollision(e);
	}
}

void Player::handleCollision()
{
}

void Player::_handleCollision(Projectile p)
{
	/*Projectile hits the player*/
	if (shieldActive) {
		StateManager::getInstance().eventManager.queueEvent(Event(EventType::ShieldHit, this));
		_loseAmmo(p.power / 2);
	}
	else {
		HP -= p.power;
		HP -= 1;
	}

}

void Player::handleCollision(Entity * e)
{
	try
	{
		Player *p = dynamic_cast<Player *>(e);
		if (p != nullptr) {
			//handlecollisoin with player;
		}
	}
	catch (const std::bad_cast& cast){
	}

	try
	{
		Projectile *p = dynamic_cast<Projectile *>(e);
		if (p != nullptr) {
			//handlecollisoin with Projectile;
			bool handle = true;
			//If projectile isnt generated by this
			if (p->getPlayerID() != getID()) {

				//Check if projectile hasnt colllided with this before
				for (int i = _collisions.size()-1; i >= 0; i--){
					CollisionStack stack = _collisions.at(i);
					if (stack._id == p->getID()) {
						if (stack.delay >= 0) {
							handle = false;
						}
					}
				}
				if (handle) {
					CollisionStack stack{ p->getID(), GameLogic::PROJECTILE_COLLISION_DELAY_GENERAL };
					_collisions.push_back(stack);
					_handleCollision(*p);
				}
			}
		}
	}
	catch (const std::bad_cast& cast){
	}
	
}

bool Player::collidableWith(Entity e)
{
	return true;
}

bool Player::collidableWith(Projectile e)
{
	return (e.getPlayerID() != getID());
}

bool Player::collidableWith(Player e)
{
	return (e.getID() != getID());
}

void Player::handleDash(int dt)
{
	dashHeld = _dashHeld;
	/*
	if (_dashHeld) {
		dashHeld = true;
	}
	else {
		dashHeld = false;
	}
	*/
	dashCooldownTime -= dt;
	if (dashCooldownTime <= 0) {
		canDash = true;
		dashCooldownTime = 0;
	}

	if (dashHeld && canDash) {
		_dashChargeHeldTime += dt;
		if (_dashChargeHeldTime >= GameLogic::PLAYER_DASH_MAXIMUM_CHARGE_TIME) {
			_dashChargeHeldTime = GameLogic::PLAYER_DASH_MAXIMUM_CHARGE_TIME;
		}
	}
	else {
		if (_dashChargeHeldTime > 0) {
			//shootHeld = false;
			canDash = false;
			dashCooldownTime = DASH_COOLDOWN;
			if (_dashChargeHeldTime >= GameLogic::PLAYER_DASH_MAXIMUM_CHARGE_TIME) {
				_dashChargeHeldTime = GameLogic::PLAYER_DASH_MAXIMUM_CHARGE_TIME;
			}
			if (state == PlayerState::Moving) {
				if (ammo >= GameLogic::PLAYER_DASH_MINIMUM_CHARGE_TIME) {
					int dashPower = 1.0f * _dashChargeHeldTime / GameLogic::PLAYER_DASH_MAXIMUM_CHARGE_TIME * GameLogic::PLAYER_DASH_MAXIMUM_ENERGY_COST;
					_loseAmmo(dashPower);
					state = PlayerState::Dashing;
					dashOrientation = orientation;
					dashOrientationX = orientationX;
					dashOrientationY = orientationY;
					dashTime = GameLogic::PLAYER_DASH_DURATION;
					dashVelocity = GameLogic::PLAYER_DASH_VELOCITY * _dashChargeHeldTime / GameLogic::PLAYER_DASH_MAXIMUM_CHARGE_TIME + GameLogic::PLAYER_MINIMUM_DASH_VELOCITY;
				}
				else {
					StateManager::getInstance().eventManager.queueEvent(Event(EventType::OutOfAmmo, this));
				}
			}
			_dashChargeHeldTime = 0;
			dashHeld = false;
		}
		dashHeld = false;
	}
	_dashHeld = false;
	/*
	_dashAmmoRechargeProgress += dt;
	if (dashAmmo >= GameLogic::PLAYER_DASH_MAX_AMMO) {
		dashAmmo = GameLogic::PLAYER_DASH_MAX_AMMO;
		_dashAmmoRechargeProgress = 0;
	}
	else {
		if (_dashAmmoRechargeProgress >= GameLogic::PLAYER_DASH_RECHARGE_COOLDOWN) {
			_dashAmmoRechargeProgress -= GameLogic::PLAYER_DASH_RECHARGE_COOLDOWN;
			if (dashAmmo < GameLogic::PLAYER_DASH_MAX_AMMO) {
				dashAmmo+=1;
			}
		}
	}
	*/
}

void Player::handleAmmo(int dt)
{
	if (ammo < 0) {
		ammo = 0;
	}
	_ammoRechargeProgress += dt;
	if (ammo >= GameLogic::PLAYER_MAX_AMMO) {
		ammo = GameLogic::PLAYER_MAX_AMMO;
		_ammoRechargeProgress = 0;
	}
	else {
		if (_ammoRechargeProgress >= GameLogic::PLAYER_AMMO_RECHARGE_COOLDOWN) {
			while (_ammoRechargeProgress >= GameLogic::PLAYER_AMMO_RECHARGE_COOLDOWN) {
				if (ammo < GameLogic::PLAYER_MAX_AMMO) {
					_ammoRechargeProgress -= GameLogic::PLAYER_AMMO_RECHARGE_COOLDOWN;
					_gainAmmo(1);
				}
			}
		}
	}

}

void Player::handleShooting(int dt)
{
	if (_shootHeld) {
		shootHeld = true;
	}
	shootCooldownTime-= dt;
	if (shootCooldownTime <= 0) {
		canShoot = true; 
		shootCooldownTime = 0;
	}
	if (shootHeld && canShoot) {
		_shotChargeHeldTime += dt;
		if (_shotChargeHeldTime >= GameLogic::PLAYER_PROJECTILE_MAXIMUM_CHARGE_TIME) {
			_shotChargeHeldTime = GameLogic::PLAYER_PROJECTILE_MAXIMUM_CHARGE_TIME;
		}
	}
	else {
		if (_shotChargeHeldTime > 0) {
			//shootHeld = false;
			canShoot = false;
			shootCooldownTime = GameLogic::PLAYER_SHOOT_COOLDOWN;
			if (_shotChargeHeldTime >= GameLogic::PLAYER_PROJECTILE_MAXIMUM_CHARGE_TIME) {
				_shotChargeHeldTime = GameLogic::PLAYER_PROJECTILE_MAXIMUM_CHARGE_TIME;
			}
			float ratio = 1.0f * _shotChargeHeldTime / GameLogic::PLAYER_PROJECTILE_MAXIMUM_CHARGE_TIME ;
			int projectilePower = 1.0f * _shotChargeHeldTime / GameLogic::PLAYER_PROJECTILE_MAXIMUM_CHARGE_TIME * GameLogic::PLAYER_PROJECTILE_MAXIMUM_ENERGY_COST;
			if (ammo >= projectilePower) {
				_loseAmmo(projectilePower);
				Projectile *p{ new Projectile(this) };
				p->durability = 1;
				p->lifetime = 600;
				p->orientation = cursorOrientation;
				p->posX = posX;
				p->posY = posY;
				p->velocityX = (GameLogic::PROJECTILE_SPEED_MAXIMUM - GameLogic::PROJECTILE_SPEED_MINIMUM) * ratio + GameLogic::PROJECTILE_SPEED_MINIMUM;
				p->velocityY = (GameLogic::PROJECTILE_SPEED_MAXIMUM - GameLogic::PROJECTILE_SPEED_MINIMUM) * ratio + GameLogic::PROJECTILE_SPEED_MINIMUM;
				p->power = projectilePower;
				p->setRadius((GameLogic::PROJECTILE_HITBOX_RADIUS_MAXIMUM - GameLogic::PROJECTILE_HITBOX_RADIUS_MINIMUM) * ratio + GameLogic::PROJECTILE_HITBOX_RADIUS_MINIMUM);
				_game->addEntity(p);
				_shotChargeHeldTime = 0;
				shootHeld = false;
				StateManager::getInstance().eventManager.queueEvent(Event(EventType::CollisionGeneral, p));
			}
			else {
				StateManager::getInstance().eventManager.queueEvent(Event(EventType::OutOfAmmo, this));
			}
		}
		shootHeld = false;
	}
	_shootHeld = false;
}
/*
void Player::_handleShooting(int dt) {

}
*/

void Player::handleShield(int dt)
{
	shieldActive = _shieldActive;
	if (!_shieldActive) {
		shieldActive = false;
		_shieldActiveDuration = 0;
		state = Moving;
	}
	else {
		_shieldActiveDuration++;
		shieldActive = true;
	}
	_shield.posX = posX;
	_shield.posY = posY;

	_shieldActive = false;
	if (shieldActive) {
		state = Shielding;
	}
}

/*Handle when Player presses the Shoot command*/
void Player::shoot() {
	_shootHeld = true;
}

void Player::dash() {
	_dashHeld = true;
	dashOrientation = orientation;
	dashOrientationX = orientationX;
	dashOrientationY = orientationY;
}

void Player::shield()
{
	_shieldActive = true;
}

void Player::_gainAmmo(int nb){
	ammo += nb;
	//StateManager::getInstance().eventManager.queueEvent(Event(EventType::GainAmmo, this));
}

void Player::_loseAmmo(int nb){
	ammo -= nb;
	StateManager::getInstance().eventManager.queueEvent(Event(EventType::LoseAmmo, this));
}

//move the 
void Player::move(float x, float y) {
	_moveEngaged = true;
}

void Player::_handleMovement(int dt) {
	/*Movement*/
	prevPosX = posX;
	prevPosY = posY;
	float orienX = orientationX / 100;
	float orienY = orientationY / 100;
	//printf("PLAYER STATE:: %d\n", state);
	switch (state) {
	case::PlayerState::Moving: {
		if (_moveEngaged) {
			int reducethespeedaittle = 100;
			velocityX += orienX * GameLogic::PLAYER_ACCELERATION_RATE;
			velocityY += orienY * GameLogic::PLAYER_ACCELERATION_RATE;
		}
		bool vXPositif = true;
		bool vYPositif = true;
		if (velocityX < 0.0f) {
			vXPositif = false;
		}
		if (velocityY < 0.0f) {
			vYPositif = false;
		}

		/*Friction*/

		if (std::abs(velocityX) <= GameLogic::PLAYER_VELOCITY_DEAD_ZONE) {
			velocityX = 0.0f;
		}
		else {
			velocityX *= GameLogic::PLAYER_FRICTION;
		}

		if (std::abs(velocityY) <= GameLogic::PLAYER_VELOCITY_DEAD_ZONE) {
			velocityY = 0.0f;
		}
		else {
			velocityY *= GameLogic::PLAYER_FRICTION;
		}

		/*Friciton 2*/
		/*
		if (velocityX <= GameLogic::PLAYER_VELOCITY_DEAD_ZONE && velocityX >= (-1.f * GameLogic::PLAYER_VELOCITY_DEAD_ZONE)) {
			velocityX = 0.0f;
		}
		else {
			velocityX *= GameLogic::PLAYER_FRICTION;
		}
		if (velocityY <= GameLogic::PLAYER_VELOCITY_DEAD_ZONE && velocityY >= (-1.f * GameLogic::PLAYER_VELOCITY_DEAD_ZONE)) {
			velocityY = 0.0f;
		}
		else {
			velocityY *= GameLogic::PLAYER_FRICTION;
		}
		*/

		/// Reduce Velocity when exceeding max ///
		if (std::abs(velocityX) > GameLogic::PLAYER_DASH_VELOCITY) {
			velocityX += orienX * -1.0f * GameLogic::PLAYER_MAX_VELOCITY_DECREASE_RATE;
		}
		if (std::abs(velocityX) > GameLogic::PLAYER_MAX_VELOCITY) {
			velocityX += orienX * -1.0f * GameLogic::PLAYER_MAX_VELOCITY_DECREASE_RATE ;
		}

		if (std::abs(velocityY) > GameLogic::PLAYER_DASH_VELOCITY) {
			velocityY += orienY * -1.0f * GameLogic::PLAYER_MAX_VELOCITY_DECREASE_RATE;
		}
		if (std::abs(velocityY) > GameLogic::PLAYER_MAX_VELOCITY) {
			velocityY += orienY * -1.0f * GameLogic::PLAYER_MAX_VELOCITY_DECREASE_RATE ;
		}
			/*
			if (vXPositif) {
				//velocityX = GameLogic::PLAYER_MAX_VELOCITY;
				velocityX -= orientationX * GameLogic::PLAYER_MAX_VELOCITY_DECREASE_RATE;
			}
			else {
				//velocityX = GameLogic::PLAYER_MAX_VELOCITY * -1.0f;
				velocityX += orientationX * GameLogic::PLAYER_MAX_VELOCITY_DECREASE_RATE * -1.0f;
			}
			*/
		
		posX += velocityX;
		posY += velocityY;
		break;

	}
	case::PlayerState::Dashing: {
		handleDash(dt);
		dashTime -= dt;

		float dashOriX = dashOrientationX / 100.f;
		float dashOriY = dashOrientationY / 100.f;
		//velocityX = dashOriX * GameLogic::PLAYER_DASH_VELOCITY;
		//velocityY = dashOriY * GameLogic::PLAYER_DASH_VELOCITY;
		velocityX = dashOriX * dashVelocity;
		velocityY = dashOriY * dashVelocity;

		/*
		posX += std::sin(dashOrientation) * (50) / 10 * dashVelocity;
		posY += std::cos(dashOrientation) * (50) / 10 * dashVelocity;
		*/

		if (dashTime <= 0) {
			state = PlayerState::Moving;
		}
		posX += velocityX;
		posY += velocityY;
		break;
	}
	case::PlayerState::Shielding:
	default:break;
	}
	//posX += std::sin(orientation) *std::abs(orientationX) / 10 * velocityX;
	//posY += std::cos(orientation)  *std::abs(orientationY) / 10 * velocityY;
	
	_moveEngaged = false;
}